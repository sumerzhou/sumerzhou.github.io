<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>react+webpack项目架构|sumerzhou's blog</title>
    <link href="myblog.css" rel="stylesheet" type="text/css">
    <script src="myblog.js" type="text/javascript"></script>
    <script src="http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
    <style>
        .textBox{
            width: 980px;
            border-radius: 20px;
            position: relative;
            padding: 10px;
            top: 105px;
            line-height: 2em;
        }
        .textBox h2{
            margin-top: 10px;
            text-indent: 2em;
            text-shadow: 2px 2px 1px dodgerblue;
        }
        .textBox h3{
            margin-top: 10px;
            border-bottom:1px solid lightblue;
            box-shadow: 2px 2px 1px black;
        }
        .textBox h4{
            text-shadow: 1px 1px 2px #4F68B0;
        }
        .textBox p{
            text-indent: 2em;
        }
        .textBox li{
            text-indent: 2em;
            list-style: none;
        }
        .textBox pre{
            display: block;
            width: 850px;
            border-left: 1px solid black;
            border-right: 1px solid black;
            box-shadow: 4px 3px 2px black;
            padding-left: 30px;
            position: relative;
            left: -30px;
            font-family: '仿宋';
            background-color: rgb(40,44,52);
            line-height: 1.5;
            font-size: 15px;
            color:white;
            overflow-y: auto;
        }
    </style>
</head>
<body>
<!--header-->
<div class="headerbox">
    <div class="headertop">
        <div class="hdtopbut">
            <a href="http://blog.hungking.cc/" target="_blank"><img src="imgs/sns_blog_off.png"></a>
            <a href="https://www.facebook.com/HoungkingHsi" target="_blank"><img src="imgs/sns_facebook_off.png"></a>
            <a href="http://globalblog.hungking.cc/" target="_blank"><img src="imgs/sns_gBlog_off.png"></a>
            <a href="http://www.linkedin.com/imisslovelove" target="_blank"><img src="imgs/sns_in_off.png"></a>
            <a href="http://www.youtube.com/imisslovelove" target="_blank"><img src="imgs/sns_youTube_off.png"></a>
            <a href="http://www.instagram.com/imisslovelove" target="_blank"><img src="imgs/sns_instagram_off.png"></a>
            <a href="http://story.kakao.com/ch/imisslovelove" target="_blank" style="background: transparent none;"><img src="imgs/sns_kakao_off.png"></a>
            <div class="hdtopbutR">
                <a href="construction.html" style="background-position-x:85px ;">Contact Me</a>
                <a href="construction.html">AboutSite</a>
                <span onclick="ifshow(0)">Language<img src="imgs/btn_globalSite_open.gif"></span>
                <ul id="lag">
                    <li>KOREAN</li><li>CHINESE</li><li>JAPANESE</li>
                </ul>
            </div>
        </div>
    </div>
    <div class="headerbotm">
        <a class="logohome" href="http://www.hungking.cc/company"><img src="imgs/blog.png"></a>
        <ul id="hdbotmUl">
            <li>
                <a href="company.html">WEB前端</a>
                <ul class="ultext1">
                    <li>
                        <a href="">HTML</a>
                        <div class="ultext2">
                            <ul>
                                <li><a href="">Corporate Overview</a></li>
                                <li><a href="">Vision of houngking</a></li>
                                <li><a href="">History of houngking</a></li>
                            </ul>
                        </div>
                    </li>
                    <li>
                        <a href="">CSS/CSS3</a>
                        <div class="ultext2">
                            <ul>
                                <li><a>Brand Story</a></li>
                                <li><a>CI</a></li>
                            </ul>
                        </div>
                    </li>
                    <li>
                        <a href="">JavaScript</a>
                        <div class="ultext2">
                            <ul>
                                <li><a>Greetings</a></li>
                                <li><a>CEO's Message</a></li>
                            </ul>
                        </div>
                    </li>
                    <li>
                        <a href="">Ajax</a>
                        <div class="ultext2">
                            <ul>
                                <li><a>hougking Affiliates</a></li>
                                <li><a>Steel</a></li>
                                <li><a>E&C</a></li>
                                <li><a>Trade</a></li>
                                <li><a>ICT</a></li>
                                <li><a>Energy</a></li>
                                <li><a>Material-Chemistry</a></li>
                                <li><a>Support</a></li>
                            </ul>
                        </div>
                    </li>
                    <li>
                        <a href="">jQuery</a>
                        <div class="ultext2">
                            <ul>
                                <li><a>Global</a></li>
                                <li><a>Asia</a></li>
                                <li><a>America</a></li>
                                <li><a>Europe&Africa</a></li>
                            </ul>
                        </div>
                    </li>
                </ul>
            </li>
            <li>
                <a href="company.html">Business Ethics</a>
                <ul class="ultext1">
                    <li>
                        <a href="">Code of Ethics</a>
                        <div class="ultext2">
                            <ul>
                                <li><a href="">CEO Message</a></li>
                                <li><a href="">Ethics Charter</a></li>
                                <li><a href="">Practice Guidelines</a></li>
                            </ul>
                        </div>
                    </li>
                    <li>
                        <a href="">Major Activities</a>
                        <div class="ultext2">
                            <ul>
                                <li><a href="">Operation of the Ethical Management System</a></li>
                                <li><a href="">Education on Corporate Ethics</a></li>
                                <li><a href="">Unethical Act Prevention System</a></li>
                                <li><a href="">External Activities and Results</a></li>
                            </ul>
                        </div>
                    </li>
                </ul>
            </li>
            <li>
                <a href="company.html">Products/Technology</a>
                <ul class="ultext1">
                    <li>
                        <a href="">Products of hounking</a>
                        <div class="ultext2">
                            <ul>
                                <li><a href="">Hot Rolled Steel</a></li>
                                <li><a href="">Steel Plate</a></li>
                                <li><a href="">Winter Day</a></li>
                                <li><a href="">Gold Rolled Steel</a></li>
                                <li><a href="">Galvanized Steel</a></li>
                                <li><a href="">Electrical Galvanized</a></li>
                                <li><a href="">Electrical Steel</a></li>
                                <li><a href="">Automotive materials</a></li>
                                <li><a href="">Stainless Steel</a></li>
                                <li><a href="">Titanium Product</a></li>
                                <li><a href="">Magnesium Product</a></li>
                                <li><a href="">Aluminum-plated products</a></li>
                            </ul>
                        </div>
                    </li>
                    <li>
                        <a href="">houngking Technology</a>
                        <div class="ultext2">
                            <ul>
                                <li><a href="">FINEX Technology</a></li>
                                <li><a href="">Strip Casting</a></li>
                                <li><a href="">Endless Hot Rolling Technology</a></li>
                                <li><a href="">Operation Technology</a></li>
                                <li><a href="">CEM Technology</a></li>
                            </ul>
                        </div>
                    </li>
                    <li style="background-image: none;">
                        <a href="">Production Process</a>
                    </li>
                    <li>
                        <a href="">Sales information</a>
                        <div class="ultext2">
                            <ul>
                                <li><a href="">e-Sales</a></li>
                                <li><a href="">e-Procurement</a></li>
                            </ul>
                        </div>
                    </li>
                </ul>
            </li>
            <li>
                <a href="company.html">Investor Relations</a>
                <ul class="ultext1">
                    <li style="background-image: none;">
                        <a href="">IR Activeties</a>
                    </li>
                    <li>
                        <a href="">Stock Information</a>
                        <div class="ultext2">
                            <ul>
                                <li><a href="">Stock Price</a></li>
                                <li><a href="">Price Comparision</a></li>
                                <li><a href="">ADR</a></li>
                                <li><a href="">houngking Stock Exchange</a></li>
                                <li><a href="">Economic Trend</a></li>
                                <li><a href="">Shareholders Demographics</a></li>
                                <li><a href="">Dividend</a></li>
                            </ul>
                        </div>
                    </li>
                    <li>
                        <a href="">Financial Information</a>
                        <div class="ultext2">
                            <ul>
                                <li><a href="">Income Statement</a></li>
                                <li><a href="">Credit Rating</a></li>
                            </ul>
                        </div>
                    </li>
                    <li>
                        <a href="">IR Archive</a>
                        <div class="ultext2">
                            <ul>
                                <li><a href="">Audit Report</a></li>
                                <li><a href="">Form 20-F</a></li>
                                <li><a href="">Annual Report</a></li>
                            </ul>
                        </div>
                    </li>
                </ul>
            </li>
            <li>
                <a href="company.html">Sustainability</a>
                <ul class="ultext1">
                    <li>
                        <a href="">Sustainability Management System</a>
                        <div class="ultext2">
                            <ul>
                                <li><a href="">Sustainability Management System</a></li>
                                <li><a href="">houngking Subsidiaries CSR Assessment</a></li>
                                <li><a href="">Risk Management</a></li>
                                <li><a href="">Stakeholder</a></li>
                                <li><a href="">Relevant Institutes Activities</a></li>
                            </ul>
                        </div>
                    </li>
                    <li style="background-image: none;">
                        <a href="">Social Responsibility </a>
                    </li>
                    <li>
                        <a href="">Environmental Management </a>
                        <div class="ultext2">
                            <ul>
                                <li><a href="">Family's Environmental Management</a></li>
                                <li><a href="">Environmental Management</a></li>
                                <li><a href="">Climate change /Energy</a></li>
                            </ul>
                        </div>
                    </li>
                    <li>
                        <a href="">Customer</a>
                        <div class="ultext2">
                            <ul>
                                <li><a href="">Marketing strategy</a></li>
                            </ul>
                        </div>
                    </li>
                    <li>
                        <a href="">Employee</a>
                        <div class="ultext2">
                            <ul>
                                <li><a href="">Employee Health / Safety</a></li>
                                <li><a href="">Organizational Culture</a></li>
                                <li><a href="">HR system</a></li>
                            </ul>
                        </div>
                    </li>
                    <li>
                        <a href="">Report</a>
                        <div class="ultext2">
                            <ul>
                                <li><a href="">Sustainability Report</a></li>
                                <li><a href="">Carbon Report</a></li>
                                <li><a href="">Conflict Minerals Disclosure</a></li>
                            </ul>
                        </div>
                    </li>
                </ul>
            </li>
            <li>
                <a href="company.html">PR Room</a>
                <ul class="ultext1">
                    <li style="background-image: none;">
                        <a href="">News room</a>
                    </li>
                    <li style="background-image: none;">
                        <a href="">News letter</a>
                    </li>
                    <li style="background-image: none;">
                        <a href="">houngking SNS</a>
                    </li>
                    <li>
                        <a href="">PR Archives</a>
                        <div class="ultext2">
                            <ul>
                                <li><a href="">Digital Brochure</a></li>
                                <li><a href="">TV Cormmercials</a></li>
                                <li><a href="">Screen Saver</a></li>
                                <li><a href="">PR Movies</a></li>
                                <li><a href="">Printed Advertisement</a></li>
                            </ul>
                        </div>
                    </li>
                    <li>
                        <a href="">Download</a>
                        <div class="ultext2">
                            <ul>
                                <li><a href="">Company</a></li>
                                <li><a href="">Products/Technology</a></li>
                                <li><a href="">Investor Relations</a></li>
                                <li><a href="">Sustainability</a></li>
                                <li><a href="">PR Room</a></li>
                            </ul>
                        </div>
                    </li>
                </ul>
            </li>
        </ul>
        <img src="imgs/btn_gnb.png" class="imgbtn" id="imgbtn" onclick="ifshow(1)">
        <img src="imgs/btn_search.png" class="imgbtn2" onclick="ifshow(2)">
        <div class="hdmenu" id="hdmenu">
            <a href="">Open submenu</a>
            <ul class="menutxt1">
                <li>
                    <a href="">Company</a>
                    <ul>
                        <li><a href="">Corporate Overview</a></li>
                        <li><a href="">Brand</a></li>
                        <li><a href="">CEO</a></li>
                        <li><a href="">hounking Affiliates</a></li>
                        <li><a href="">hounking Overseas</a></li>
                    </ul>
                </li>
                <li>
                    <a href="">Business Ethics</a>
                    <ul>
                        <li><a href="">Code of Ethics</a></li>
                        <li><a href="">Major Activities</a></li>
                    </ul>
                </li>
                <li>
                    <a href="">Products/Technology</a>
                    <ul>
                        <li><a href="">Products of houngking</a></li>
                        <li><a href="">hounking Technology</a></li>
                        <li><a href="">Production Process</a></li>
                        <li><a href="">Sales informtion</a></li>
                    </ul>
                </li>
                <li style="padding: 0px;">
                    <a href="">Investor Relations</a>
                    <ul>
                        <li><a href="">IR Activities</a></li>
                        <li><a href="">Stock Information</a></li>
                        <li><a href="">Financial Information</a></li>
                        <li><a href="">IR Archive</a></li>
                    </ul>
                </li>
                <li>
                    <a href="">Sustainability</a>
                    <ul>
                        <li><a href="">Suatainability Management System</a></li>
                        <li><a href="">Social Redponsibility</a></li>
                        <li><a href="">Environmental Management</a></li>
                        <li><a href="">Customer</a></li>
                        <li><a href="">Employee</a></li>
                        <li><a href="">Report</a></li>
                    </ul>
                </li>
                <li>
                    <a href="">PR Room</a>
                    <ul>
                        <li><a href="">Newsroom</a></li>
                        <li><a href="">Newsletter</a></li>
                        <li><a href="">houngking SNS</a></li>
                        <li><a href="">PR Archives</a></li>
                        <li><a href="">Download</a></li>
                    </ul>
                </li>
                <li>
                    <a href="">Contact Us</a>
                    <ul>
                        <li><a href="">Q&A</a></li>
                        <li><a href="">Search</a></li>
                        <li><a href="">Location</a></li>
                        <li><a href="">Sitemap</a></li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>
</div>
<!--text-->
<div class="textBox">
    <h2>react+webpack项目架构</h2>
    <h3>1,项目基本目录结构</h3>
    <p>views目录：views目录用于存放项目功能模块的页面，需要根据路由配置情况分割子级目录。</p>
    <p>config目录：存放一些配置目录，比方第三方类库应用，路由配置等。</p>
    <p>store目录：用于存放项目store相关的文件，包括数据获取的封装等。store是现在webapp比较流行的一种开发模式，用于存放一些数据管理的东西。</p>
    <p>components目录：用于存放非业务组件，或者在多个业务间都需要用到的公用组件。</p>
    <p>在client目录下新增views、config、store、components目录，修改后的client目录如下：</p>
    <img src="imgs/react3.png" alt="" style="padding-left:30px;">
    <p>App.jsx是作为所有页面的主入口，把它放到views根目录下。</p>
    <p>views下面的所有子目录都建一个index.jsx。每个子目录表示一个页面，要引用某个页面只需要引用子目录里的index.jsx就可以了,作为一个入口。</p>
    <p>在这两个页面的index.jsx文件中写一点简单的代码:</p>
    <pre>
    import React from 'react'
    export default class TopicList extends React.Component {
      componentDidMount() {
        // do something here
      }
      render() {
        return (
          &lt;div&gt;this is topic list~&lt;/div&gt;   //detail页面把div中要显示的内容改为‘this is topic detail’
        )
      }
    }</pre>
    <h3>2,路由配置</h3>
    <h5>前端路由的实现：</h5>
    <p>HTML5 APi中的history API能够在url变化的时候js代码可以监听到这个事件，然后阻止浏览器的默认刷新页面的行为。然后在js代码中去执行我们想要的操作，一般来说会去重新渲染一个新页面，同时通过API请求获取数据，再把想要显示的数据结合页面把内容填充进去展示给用户。在history API出现之前，可以使用hash跳转实现。</p>
    <h5>react中的路由:</h5>
    <p>react-router是一个非常好用的路由控制插件，能像书写jsx组件一样控制路由的跳转。首先安装react-router:</p>
    <pre>
    npm i react-router -S </pre>
    <p>react-router集合了react-router-dom和react-router-native。这个项目只做网站，还是使用react-router-dom比较好(react-router 4.X版本)。再安装一下react-router-dom ：</p>
    <pre>
    npm i react-router-dom -S </pre>
    <p>在config/router.jsx中书写路由：</p>
    <pre>
    import React from 'react'
    import { Route, Redirect } from 'react-router-dom'
    import TopicList from '../views/topic-list/index'
    import TopicDetail from '../views/topic-detail/index'

    export default () => [
      &lt;Route path="/" render={() => &lt;Redirect to="/list" /&gt;} exact /&gt;,
      &lt;Route path="/list" component={TopicList} /&gt;,
      &lt;Route path="/detail" component={TopicDetail} /&gt;,
    ]  //react16中，不需一个组件render的内容必须有父标签然后所有东西都放在父标签，可以返回一个数组在同一层级的。</pre>
    <p>修改编辑App.jsx:</p>
    <pre>
    import React from 'react'
    import { Link } from 'react-router-dom'
    import Routes from '../config/router'

    export default class App extends React.Component {
      componentDidMount(){  //暂时为了防止eslint报错，加上这个生命周期函数
        // do something here
      }
      render(){
        return [
          &lt;div&gt;
            &lt;Link to="/"&gt;首页&lt;/Link&gt;
            &lt;br /&gt;
            &lt;Link to="/detail"&gt;详情页&lt;/Link&gt;
          &lt;/div&gt;,
          &lt;Routes /&gt;
        ]
      }
    }</pre>
    <p>编辑app.js 。引入BrowserRouter，包裹在整个应用的最外层，包裹住整个app。这样路由才会生效。</p>
    <pre>
    ...
    import { BrowserRouter} from 'react-router-dom'   //注意引用位置
    ...
    const render = (Component) => {
      ReactDOM.hydrate(
        &lt;AppContainer&gt;
          &lt;BrowserRouter&gt;
            &lt;Component /&gt;
          &lt;/BrowserRouter&gt;
        &lt;/AppContainer&gt;,
        root,
      );
    };
    ...</pre>
    <p>此时运行npm run dev:client命令，发现eslint报‘Unexpected use of file extension "jsx" for "./views/App.jsx" ’（eslint希望import module的时候不需要去写后缀名）和‘Can't resolve '../config/router' in 'F:\React\react-webpack\client\views'’（因为webpack默认是只认识.js文件的，js文件不写后缀没关系）等处的错误。</p>
    <p>ps:把报“jsx-a11y/anchor-is-valid”类型错误的规则在.eslintrc文件中去掉。</p>
    <p>先把app.js中需要引入'./views/App.jsx'的地方都改为‘./views/App'。然后在webpack.base.js中加一条配置：</p>
    <pre>
    ...
    output: {
      ...
    },
    resolve: {
      extensions: ['.js','.jsx']  //申明不需要写后缀名的module
    },
    ...</pre>
    <p>此时重新启动npm run dev:client成功。</p>
    <h3>3,store配置</h3>
    <p>伴随react一起诞生的，是Facebook推出的一套前端数据流方案，叫做flux，在其中数据存储的地方，就叫做store。</p>
    <p>以前开发web app更多地是使用mvc模式，但mvc模式在前端不是特别适用，因为很多数据都是异步的，然后每个页面可能会共享一部分的数据。这些数据更新的时候，没有很好的办法让view层检测到这些数据的更新以及什么时候会更新，这会导致视图层跟model层出现一定的脱节，产生一定的问题。</p>
    <p>flux又叫做单项数据流,也就是说整个app有个单独存放数据的地方，即store。所有页面上的内容都是根据store的内容渲染出来的。store里面数据的变化会立即影响到视图层的渲染效果。这就解决了mvc模式下经常会出现的数据依赖关系错乱的问题，让数据维护都集中在一个点上。我们只需要使用一个action去处理数据，然后视图就会很好的更新成最新的样子。</p>
    <p>跟react一起推出，是因为react是一个纯视图层解决方案，它的虚拟DOM让我们即便把整个数据更新了，react也能非常搞笑的处理视图的重新渲染。因为伴随视图层解决方案的进化，导致使用这种单一数据流方式来创建应用。</p>
    <p>在本实战项目中，我们使用<a href="https://mobx.js.org/" target="_blank">Mobx</a>这个flux实现的后起之秀。它跟传统的flux有一定的区别。Mobx是react的一个数据框架，它的所有数据一但更改，绑定的数据的地方会立刻更新。这就是在JavaScript中新起的一种reactive的编程模式，它的使用方法相比Redux（有mutation、action、dispatch等概念）等这些纯flux实现要简单很多。</p>
    <h4>项目代码:</h4>
    <p>先在store目录下新建一个app-state.js文件。该目录下的store.js是用来创建整个应用的store的，而应用可能会分很多不同的小的store。app-state.js用来存储跟业务逻辑没有太大关系的,用来控制应用展示的纯前端相关的交互逻辑之类的东西。</p>
    <p>在正式使用mobx前，为了使用装饰器，需要在.babelrc进行配置：</p>
    <pre>
    {
      "presets": [
        ["es2015",{"loose":true}],
        "stage-1",    //针对非es6的语法，是es@next的
        "react"
      ],
      "plugins": ["transform-decorators-legacy","react-hot-loader/babel"]  //transform-decorators-legacy要放在plugins第一项，否则会出现一定问题
    }</pre>
    <p>安装以上新增配置：</p>
    <pre>
    npm i babel-plugin-transform-decorators-legacy babel-preset-stage-1 -D </pre>
    <p>安装Mobx:</p>
    <pre>
    npm i mobx mobx-react -S
    //mobx-react是Mobx连接react应用的工具</pre>
    <p>安装完后就可以使用装饰器了。去app-state.js中定义：</p>
    <pre style="height: 300px;">//app-state.js
    import { observable, computed, autorun, action } from 'mobx'

    export class AppState {
      @observable count = 0;  //@observable指定count是个reactive的值，更新之后会实时显示到视图层。
      @observable name = 'Jokcy';
      @computed get msg() {
        return `${this.name} say count is ${this.count}`
      }
      @action add() {
        this.count += 1;
      }
      @action changeName(name) {
        this.name = name;
      }
    }
    const appState = new AppState();
    autorun(() => {
      console.log(appState.msg)
    });
    setInterval(() => {
      appState.add();
    },1000);

    export default appState</pre>
    <p>然后把app-state.js连接到app上。在app.js上修改，用法跟browserrouter类似，在整个应用的外面包一层。这种包一层的用法在很多情况下是使用react里面的一个隐藏API context（上下文关系），context可以让内容从顶层传到每个组件的任何地方都可以拿到。这样的话连接起来API就变得比较简单。所以很多插件都会选择这种方式来做。</p>
    <pre>//app.js
    ...
    import { Provider } from 'mobx-react'
    ...
    import appState from './store/app-state'
    const root = document.getElementById('root');
    const render = (Component) => {
      ReactDOM.hydrate(
        &lt;AppContainer&gt;
          &lt;Provider appState={appState}&gt;
            ...
          &lt;/Provider&gt;
        &lt;/AppContainer&gt;,
    ...</pre>
    <p>Provider提供之后，我们可以在应用里非常方便地拿到在Provider上定义的属性。比如在topic-list/index.jsx中：</p>
    <pre style="height: 300px;">//  topic-list/index.jsx
    import React from 'react'
    import { observer, inject } from 'mobx-react'
    import PropTypes from 'prop-types'
    import { AppState } from '../../store/app-state'

    //inject用来注入provider上提供的东西到组件
    //observer告诉我们这个组件是observable的，它是reactive的，store里面的值一更新组件里的内容也会更新。
    @inject('appState') @observer
    export default class TopicList extends React.Component {
      constructor() {
        super();
        this.changeName = this.changeName.bind(this)
      }
      componentDidMount() {
        // do something here
      }
      changeName(event) {
        this.props.appState.changeName(event.target.value)
      }
      render() {
        return (
          &lt;div&gt;
            &lt;input type="text" onChange={this.changeName} /&gt;
            &lt;span&gt;{this.props.appState.msg}&lt;/span&gt;
          &lt;/div&gt;
        )
      }
    }

    TopicList.propTypes = {
      appState: PropTypes.instanceOf(AppState).isRequired,
    };//appState是AppState类的一个实例</pre>
    <p>在几个版本之前react已经把propTypes这个检测props类型的工具拆分出去了，所以需要再安装一个包prop-types：</p>
    <pre>
    npm i prop-types -S </pre>
    <p>完成后，启动npm run dev:client,在浏览器localhost:8888查看页面效果。</p>
    <p>ps：有些版本react会报一个关于‘key’的错误，这是因为react return的标签元素如果是个子节点是数组的标签，我们需要给数组的每个项加上一个key来区分。</p>
    <h3>4, Cnode API代理实现</h3>
    <p>首先打开https://cnodejs.org/api(cnode开发API)。</p>
    <p>如果我们所有接口都是在页面端发送请求到cnodejs API这边，然后返回内容就可以的话，那我们直接使用代理就可以。但这里会存在一个问题，有些接口需要用户登录之后才能去调用，这边的登录是通过一个叫accessToken的东西。我们发送的请求如果里面有accessToken这个参数，则代表我们有权限去请求接口。但这个accessToken肯定不能储存在浏览器端，不安全。我们需要在获取accessToken之后存在nodejs端的session里面，然后接下去的所有的请求就代表我们在服务端去检测我们的session有没有accessToken，如果有就表示已经登录可以发送这个请求，若没有就告诉浏览器端需要先登录。</p>
    <p>我们需要安装几个工具:</p>
    <pre>
    npm i body-parser express-session query-string -S </pre>
    <p>body-parser是用来转化我们的请求的body的，转化为json格式的数据以便于后期的使用。</p>
    <p>express-session是express的一个插件，用来存放服务端的session。</p>
    <p>query-string用来转化通过连接请求过来的url后面‘？’某一个参数等于什么的这种形式的string，把其转化为json格式的数据，让我们可以方便的使用。</p>
    <p>安装完后修改server.js：</p>
    <pre>//  server/server.js
    ...
    const bodyParser = require('body-parser');
    const session = require('express-session');
    ...
    const app = express();
    app.use(bodyParser.json()); //把app的json格式的请求数据转化成req.body上面的数据。后面写业务逻辑的时候只要去调用req.body的内容就可以拿到请求里面的数据。
    app.use(bodyParser.urlencoded({extended:false}));
    app.use(session({
      maxAge: 10*60*1000,  //设10分钟，测试用不需要太久。真正上线时，session需要存在数据库中，作为缓存等。因为我们现在没有用数据库，就直接存在内存中，跟着我们的服务一起，服务一但宕机或关机，session就没有了，下次进来需要重新登录。
      name:'tid',  //session会放一个cookieid到浏览器端，给这个cookieid取一个名字，随便定义。
      resave:false,  //每次请求是否要重新生成一个cookieid。若为true，会有比较大的资源浪费。
      saveUninitialized:false,   //跟resave差不多。
      secret:'react cnode'     //用自定义的字符串加密cookie，以保证cookie在浏览器端不被解密。
    }));
    ...</pre>
    <p>然后在server/util目录下新建一个文件handle-login.js。login接口需要单独处理，因为要存到session里面，不可能直接代理到cnode接口然后去返回数据给浏览器。我们把数据存到session里面，在后续调用需要登陆的接口时都可以用到这些数据。</p>
    <pre style="height: 300px;">// handle-login.js
    const router = require('express').Router();
    const axios = require('axios'); //引用axios,因为我们要发送请求
    const baseUrl = 'https://cnodejs.org/api/v1';

    router.post('/login',function (req,res,next) {
      axios.post(`${baseUrl}/accesstoken `,{
        accesstoken:req.body.accessToken
      })
        .then(resp => {
          if(resp.status == 200 && resp.data.success){
            req.session.user = {
              accessToken: req.body.accessToken,
              loginName: resp.data.loginname,
              id: resp.data.id,
              avatarUrl:resp.data.avatar_url
            };
            res.json({
              success:true,
              data:resp.data
            })
          }
        })
        .catch(err => {
          if(err.response){
            //response的意思是请求有返回，只是有业务逻辑的错误而不是服务器报错。
            res.json({
              success:false,
              data:err.response
            })
          }else {
            next(err); //把错误抛给全局的错误处理器去处理。
          }
        })
    });
    module.exports = router;</pre>
    <p>登陆接口完成了，然后去代理其他接口。在util目录下新建一个proxy.js文件，这个文件里把所有发向cnode API的接口全部代理出去。</p>
    <pre style="height: 300px;">// proxy.js
    const axios = require('axios');
    const baseUrl = 'https://cnodejs.org/api/v1';
    module.exports = function (req,res,next) {
      const path = req.path;
      const user = req.session.user || {};  //判断用户是否登录
      const needAccessToken = req.query.needAccessToken;

      if(needAccessToken && !user.accessToken){
        res.status(401).send({
          success:false,
          msg:'need login'
        })
      }

      /** 进行代理 **/
      //我们并不知道这个请求有没有一个query。如果是get请求的话可能会有query的参数，不能直接把query传过去，因为有我们自己加的一些属性，比如needAccessToken。需要把query重新定义一下：
      const query = Object.assign({},req.query);
      if(query.needAccessToken) delete query.needAccessToken;
      //method跟客户端发送过来的请求是一样的
      //在axios里面，query是用params这个key来传递的。data是req的body，body需要加上accessToken，即便对方不需要accessToken加上也没关系。
      //cnode API有个小问题，需要加上headers。因为cnode API使用axios直接发送时，它的content-type是json的，cnode API有些API可以接受application json有些不能，只能用form-data传输。为了防止出现问题，把所有content-type设为‘application/x-www-form-urlencoded’,这样axios发送请求的时候用form data的形式发送请求。
      axios(`${baseUrl}${path}`,{
        method: req.method,
        parmas:query,
        data:Object.assign({},req.body,{
          accesstoken:user.accessToken
        }),
        headers:{
          'Content-Type':'application/x-www-form-urlencoded'
        }
      }).then(resp => {
        if(resp.status == 200){
          res.send(resp.data)
        }else {
          res.status(resp.status).send(resp.data)
        }
      }).catch(err => {
        if(err.response){
          res.status(500).send(err.response.data)
        }else {
          res.status(500).send({
            success:false,
            msg:'未知错误'
          })
        }
      })
    };</pre>
    <p>然后去server.js中使用这两个新建的文件：</p>
    <pre>
    ...
    //一定要放在服务端渲染的代码之前。因为服务端代码所有请求来都会返回，所以要先处理API，API拦截到需要处理的，那API直接返回就可以了。
    app.use('/api/user',require('./util/handle-login'));
    app.use('/api',require('./util/proxy'));

    if(!isDev){
    ...</pre>
    <p>然后启动服务npm run dev:server,测试一下接口(server.entry.js会有个报错，把import的jsx文件后缀去掉.)。</p>
    <p>测试接口我们使用一个工具，在chrome上可以安装的插件postman。在postman启动后，输入想要请求的地址(localhost:3333)下的接口，比如/api/topics。输入localhost:3333/api/topics后就可以看到数据了。</p>
    <h3>5,调试接口代理</h3>
    <p>用实际中在页面发送请求的方式来测试我们的API是否能正常运行。</p>
    <p>对于需要accesstoken去调用的接口，我们在服务端把accesstoken放到请求的参数里面去，然后发送给cnode一端，这样就可以请求需要的接口了。</p>
    <p>在views目录下新增一个test目录，在test目录里新建一个api-test.jsx文件。在api-test.jsx中写一个简单的组件，可以点击按钮发送请求。</p>
    <pre style="height: 300px;">// api-test.jsx
    import React from 'react'
    import axios from 'axios'

    //下面代码只用来测试，所以不希望eslint检测，可使用以下注释方式：
    /* eslint-disable */
    export default class TestApi extends React.Component {
      getTopics(){
        axios.get('/api/topics')
          .then(resp => {
            console.log(resp)
          }).catch(err => {
            console.log(err)
        })
      }
      login(){
        //accessToken去cnode网站登录账号后的设置中获取。
        axios.post('/api/user/login',{
          accessToken:'*****************'
        }).then(resp => {
          console.log(resp)
        }).catch(err => {
          console.log(err)
        })
      }
      markAll(){
        axios.post('/api/message/mark_all?needAccessToken=true')
          .then(resp => {
            console.log(resp)
          }).catch(err => {
          console.log(err)
        })
      }
      render(){
        return (
          &lt;div&gt;
            &lt;button onClick={this.getTopics}&gt;topics&lt;/button&gt;
            &lt;button onClick={this.login}&gt;login&lt;/button&gt;
            &lt;button onClick={this.markAll}&gt;markAll&lt;/button&gt;
          &lt;/div&gt;
        )
      }
    }
    /* eslint-enable */</pre>
    <p>test页面写好之后把它加到router.jsx里面,这样才能在应用里访问到：</p>
    <pre>
    ...
    import TestApi from '../views/test/api-test'
    export default () => [
        ...
        &lt;Route path="/test" component={TestApi} /&gt;,
    ]</pre>
    <p>然后启动服务。client端和server端的服务都要启动。这里还有个注意点，在webpack-config-client.js的devServer中要加一个配置，因为现在加了store和router之后，服务端渲染是不能够直接使用的，需要再升级服务端渲染的配置（后面会讲到）。现在只能用客户端的页面访问去测试我们的接口。为了使接口访问能到我们的服务端，在webpack-config-client.js的devServer中加一个叫proxy的配置:</p>
    <pre>// webpack-config-client.js
    ...
    config.devServer = {
        host:'0.0.0.0',
        port:'8888',
        ...
        proxy:{
            '/api':'http://localhost:3333'
        }
    };
    ...</pre>
    <p>这样通过客户端启动的devServer去访问的请求，只要是‘/api’下面的，它同样会代理到服务端的代码上面，这就是使用‘/api’这样的固定前缀的好处。</p>
    <p>然后启动npm run dev:client和npm run dev:server。在页面上访问localhost:8888/test,查看几个接口的访问情况。</p>
    <p>打开浏览器的network，然后点击topics按钮，可以看到请求成功了，preview里有数据返回的详细信息。再点击login按钮，请求也成功，它的headers头信息里有个set-cookie，下面有个‘tid’,这个就是服务端返回的cookie信息，拿到这个之后，浏览器会自动存储这个cookie信息，然后在下次请求时把cookie信息带到服务端，这样服务端就能读取存在服务端的session里面的用户数据。接着点击markAll按钮，发现返回了500的报错。</p>
    <p>原来，application/x-www-form-urlencoded格式的Content-Type，与对应的数据‘data’直接传的一个json Object(proxy.js中Object.assign返回的对象)翻译出的json字符串的数据格式是不对应的。所以需要修改下：</p>
    <pre>// proxy.js
    ...
    const querystring = require('query-string');
    //在没有用querystring.stringify转化前，字符串是以{'accesstoken':'xxx'}这样的形式传输的；而使用这个转化后，就变为'accesstoken=xxx'这样的格式。
    ...
        axios(`${baseUrl}${path}`,{
            ...
            data:querystring.stringify(Object.assign({},req.body,{
              accesstoken:user.accessToken
            })),
    ...</pre>
    <p>注意：若proxy.js中headers的‘Content-Type’如果写错，cnode API那边接收的时候就不会是我们希望的解析的方式去解析‘data’这一块，导致没有办法获得body里面的数据，拿不到accesstoken，就会报错。</p>
    <p>保存修改后，服务会自动重启。我们需要重新login一下，然后再点击markAll按钮，请求就成功了。</p>
    <h4>两个小问题：</h4>
    <h5>若api-test.js中给的accessToken的值使登录错误:</h5>
    <p>会发现请求一直没有返回，这是因为handle-login.js的catch err返回的data是err.response，而response是个非常大的JavaScript对象，它里面有非常多的嵌层。使用res.json()的时候，它默认会把内容用json.stringify来转化成字符串。因为response很大，它无法转化成字符串。所以，我们需要使用err.response.data来返回值：</p>
    <pre>// handle-login.js
    ...
    .catch(err => {
      if(err.response){
        res.json({
          success:false,
          data:err.response.data
        })
      }else {
        next(err); //把错误抛给全局的错误处理器去处理。
      }
    })
    ...</pre>
    <p>重试之后会发现，返回了正确的错误信息。</p>
    <h5>proxy.js中当get请求需要accesstoken时:</h5>
    <p>proxy.js进行代理时，我们之前是把accesstoken放在body里面，但如果是一个get请求需要accesstoken，我们需要在query数据格式上去做文章：</p>
    <pre>// proxy.js
    ...
    const query = Object.assign({},req.query,{
        accesstoken:(needAccessToken && req.method === 'GET') ? user.accessToken : ''
    });
    if(query.needAccessToken) delete query.needAccessToken;
    axios(`${baseUrl}${path}`,{
        method: req.method,
        parmas:query,
        data:querystring.stringify(Object.assign({},req.body,{
          accesstoken:(needAccessToken && req.method === 'POST') ? user.accessToken : ''
        })),
    ...</pre>
    <p>这样就确保不同的请求方法时也会有对应的accesstoken。</p>
    <h3>6,服务端渲染优化</h3>
    <p>前端代码加入了router和store之后，对于服务端渲染会有一定影响。</p>
    <p>因为需要控制router的跳转，浏览器的请求过来之后，服务端渲染的内容需要根据router不同的路径映射来返回不同的HTML内容。使用者可能从任意路由进入我们的网站，不可能说每个路由进来跳转给用户的页面效果是一样的，不然服务端渲染就没有任何意义。所以需要在服务端渲染中使用路由跳转，在返回给客户端的时候就是指定页面。</p>
    <p>服务端渲染的时候，会将当前需要展示给客户的页面上的数据全部渲染到对应的页面也就是对应的组件当中。内容渲染完后可以拿到HTML，但内容给客户端之后，客户端的js又会重新去渲染一次，这个时候如果没有拿到服务端渲染时用到的数据，就需要重新通过API请求再去服务端请求一次数据。这样一次页面展示需要通过两次请求，会造成浪费。所以需要在服务端渲染优化这些内容。</p>
    <p>先打开server.entry.js。app.js中客户端代码的很多东西也需要渲染到服务端渲染中。</p>
    <pre style="height: 300px;">// server.entry.js
    import React from 'react'
    //这里跟客户端使用的BrowserRouter不一样，StaticRouter是react router专门提供做服务端渲染的组件。
    import { StaticRouter } from 'react-router-dom'
    import { Provider, useStaticRendering } from 'mobx-react'
    import App from './views/App'

    //useStaticRendering也是专门在服务端渲染时候mobx-react提供的一个工具。告诉它使用静态的渲染。
    //具体做的事情是，让mobx在服务端渲染的时候不会重复数据变换。
    //Mobx是个reactive的框架，每一次数据变化会造成其他一些方法的调用，比方说computed的方法。在服务端渲染时，如果正常使用客户端代码在做它会有一个bug，就是它的一次渲染导致computed经常去执行非常多次数而且如果改的变量比较多会造成重复引用重复调用的问题，这样会导致内存溢出。所以提供了useStaticRendering去使用。
    useStaticRendering(true);
    //服务端的store需要在服务端渲染的时候去生成，因为服务端渲染会有不同的请求进来，不可能将同一个store在不同的请求里去使用。因为一个store第一次请求的时候可能已经初始化一些数据了，在第二次请求时又去使用这个store又初始化另外一部分数据，这样造成的结果就是数据的改来改去。所以每次这个store都要重新创建，所以从外面传入store。
    //在provider上可以提供多个store，所以传入stores,它是个键值对的对象。
    //StaticRouter接收两个参数：
    //一个context，它是服务端渲染时传给StaticRouter的对象，它会在静态渲染时对这个对象进行一些操作，然后返回一些有用的信息去做些对应的操作。比如说要做redirect，它会在context对象上加url告诉我们要redirect到某个地方，那我们可以在服务端直接redirect到那个地方。所以这个对象也要从外面传进来。
    //另一个是location，它是现在这个请求的url。
    export default (stores,routerContext,url) => (
        &lt;Provider {...stores}&gt;
          &lt;StaticRouter context={routerContext} location={url}&gt;
            &lt;App /&gt;
          &lt;/StaticRouter&gt;
        &lt;/Provider&gt;
    )</pre>
    <p>然后需要修改下app-state.js。把export default的部分由new AppState()的实例变为class。不需要在这里创建实例，实例会在其他地方去创建。因为在服务端渲染的时候，每次都需要生成一个新的store实例。</p>
    <pre>//app-state.js
    import { observable, computed, action } from 'mobx'
    export default class AppState {
      @observable count = 0;
      @observable name = 'Jokcy';
      @computed get msg() {
        return `${this.name} say count is ${this.count}`
      }
      @action add() {
        this.count += 1;
      }
      @action changeName(name) {
        this.name = name;
      }
    } </pre>
    <p>在app.js中对应做出修改：</p>
    <pre>// app.js
    ...
    - import appState from './store/app-state'
    + import AppState from './store/app-state'
    ...
        &lt;Provider appState={new AppState()}&gt;
    ...</pre>
    <p>在store.js里做一些操作：</p>
    <pre>// store.js
    import AppStateClass from './app-state'

    export const AppState = AppStateClass;
    export default {
      AppState,
    }
    //这个函数是专门给服务端渲染用的
    export const createStoreMap = () => {
      return {
        appState:new AppState(),
      }
    };</pre>
    <p>回到server.entry.js，把createStoreMap加进来：</p>
    <pre>// server.entry.js
    ...
    import App from './views/App'
    import { createStoreMap } from './store/store'
    ...
    export { createStoreMap }</pre>
    <p>然后到dev-static.js去做一些操作：</p>
    <pre>// dev-static.js
    ...
    let serverBundle,createStoreMap;
    serverCompiler.watch({},(err,stats) => {
        ...
        serverBundle = m.exports.default;
        createStoreMap = m.exports.createStoreMap; //把createStoreMap方法拿进来
    });
    module.exports = function (app) {
        ...
        getTemplate().then(template => {
            const routerContext = {};
            //serverBundle现在已不是一个直接可以渲染的内容，而是一个方法，所以需要根据这个方法去创建渲染内容。
            const app = serverBundle(createStoreMap(),routerContext,req.url);
            const content = ReactDomServer.renderToString(app);
        ...
    };</pre>
    <p>然后，启动client和server，在localhost:3333查看效果。</p>
    <p>这只是一个最基本的服务端渲染的内容。若路由中间有个redirect，比如path='/'时redirect到/list，如果不在服务端渲染里去做redirect，会得到什么结果呢？直接访问默认路由‘/’，实际渲染出的内容是‘首页’和‘详情页’两个链接，没有list下面的内容。而我们希望的是在服务端渲染的时候直接redirect掉，然后真正返回的内容就是我们想要返回的内容。这部分要如何操作呢？</p>
    <p>首先在dev-static.js中去判断一下routerContext。因为在有redirect的情况下，react-router会给routerContext加一个属性url，如果有这个url属性就直接在服务端redirect掉。</p>
    <pre>// dev-static.js
    ...
    getTemplate().then(template => {
        ...
        const content = ReactDomServer.renderToString(app);
        //在renderToString后才能拿到routerContext
        if(routerContext.url){
          res.status(302).setHeader('Location',routerContext.url);//通过在header上设置location去让浏览器自动跳转。
          res.end();//结束这次请求
          return
        }
        res.send(template.replace('&lt;!--app--&gt;',content));
    })
    ...</pre>
    <p>重新试一下localhost:3333，会发现localhost请求的headers信息中是302的请求，location是‘/list’。</p>
    <p>接下去，我们希望在服务端渲染的时候要用到一些异步的数据去渲染内容，比方说在topic-list index.jsx中，我们需要msg的内容改变，且改变的过程是异步的。这个异步的过程，react本身并没有提供这样的功能在组件里面写一个方法去异步调用，但是在服务端渲染里去调用。</p>
    <p>我们需要安装一个组件去解决这个问题：react-async-bootstrapper</p>
    <pre>
    npm i react-async-bootstrapper -S</pre>
    <p>安装完后，打开dev-static.js,把这个包给引入。这个包是使用import和export这种模式开发的，所以require引入的时候后面需要用.default(ps:这个包的新版本中可以直接require，不需要.default了)。</p>
    <pre>// dev-static.js
    ...
    const asyncBootstrap = require('react-async-bootstrapper').default;
    ...
        getTemplate().then(template => {
            const routerContext = {};
            const app = serverBundle(createStoreMap(),routerContext,req.url);
            asyncBootstrap(app).then(() => {
              //asyncBootstrap方法执行app之后返回异步的结果，这个时候已经可以拿到routerContext。
              if(routerContext.url){
                ...
              }
              const content = ReactDomServer.renderToString(app);
              res.send(template.replace('&lt;!--app--&gt;',content));
            });
        })
    ...</pre>
    <p>asyncBootstrap方法执行app之后返回异步的结果，这个时候已经可以拿到routerContext。这个方法的作用是：比如，在topic-list index.jsx里创建一个叫asyncBootstrap的方法，这个方法里可以去异步操作一些数据和想要的内容，然后在dev-static.js里调用asyncBootstrap方法时，它会去执行TopicList组件里面的这个asyncBootstrap方法，等执行完成之后，才会继续渲染的工作。所以这个方法能够很好的让我们在TopicList组件的asyncBootstrap中去执行一些数据的初始化。</p>
    <p>在topic-list/index.jsx写一些测试的代码：</p>
    <pre>// topic-list/index.jsx
    ...
    componentDidMount() {
        // do something here
    }
    asyncBootstrap() {
        return new Promise((resolve) => {
            setTimeout(() => {
                this.props.appState.count = 3;
                resolve(true);//一定要resolve(true),asyncBootstrap会根据resolve的内容true还是false来决定这个方法有没有执行成功。
            })
        })
    }
    ...</pre>
    <p>然后去dev-static.js看一下stores的结果:</p>
    <pre>// dev-static.js
    ...
    getTemplate().then(template => {
        ...
        const stores = createStoreMap();
        const app = serverBundle(stores,routerContext,req.url);
        asyncBootstrap(app).then(() => {
          ...
          console.log(stores.appState.count);
          const content = ReactDomServer.renderToString(app);
          ...
        });
    })
    ...</pre>
    <p>刷新浏览器后，可以看到启动服务的命令窗口count的输出是3，说明组件TopicList内的asyncBootstrap方法已经执行了。在浏览器查看网页源代码count拿到的是3，但渲染到页面上还是0，而且网页console还报了一个错‘text content did not match’。因为服务端返回的是3，客户端渲染出的是0，这个就是服务端渲染时用到的数据跟客户端渲染时用到的store里的数据不同步。要解决这个问题，要去app-state.js加一个toJson方法：</p>
    <pre>// app-state.js
    ...
    @action changeName(name) {
      this.name = name;
    }
    toJson() {
      return {
        count: this.count,
        name: this.name,
      }
    }
    ...</pre>
    <p>这个toJson方法是用在服务端渲染的时候将AppState实例在服务端渲染完成后将得到的数据以json格式拿到，之后用这部分数据想办法放到客户端代码里，让它init的时候就能获得这部分内容。那如何做呢？打开dev-static.js:</p>
    <pre>// dev-static.js
    ...
    const getStoreState = (stores) => {  //这样就形成了在服务端渲染结束之后，数据的默认值的情况。
      return Object.keys(stores).reduce((result,storeName) => {
        result[storeName] = stores[storeName].toJson();
        return result
      },{})
    };
    module.exports = function (app) {
        ...
        asyncBootstrap(app).then(() => {
              ...
              const state = getStoreState(stores); //拿到想要的值。
              const content = ReactDomServer.renderToString(app);
              res.send(template.replace('&lt;!--app--&gt;',content));
            });
    ...</pre>
    <p>拿到的state这部分数据如何让客户端代码拿到呢？需要一个方法把数据插到HTML内容里。这时候的res.send已经不能简单地解决这个问题了。需要在webpack.config.client.js下面新建HTMLPlugin：</p>
    <pre>// webpack.config.client.js
    ...
    const config =webpackMerge(baseConfig,{
        ...
        plugins:[
            new HTMLPlugin({
                template:path.join(__dirname,'../client/template.html')
            }),
            new HTMLPlugin({
                template:'!!ejs-compiled-loader!'+path.join(__dirname,'../client/server.template.ejs'),//不能使用默认的loader
                filename:'server.ejs' //指定filename，以便方便地获取内容
            })//最终需要拿到一个可以用模板引擎去渲染的内容，这样可以方便地把数据插到想要的地方。
        ]
    });
    ...</pre>
    <p>在client目录下新建一个server.template.ejs模板文件：</p>
    <pre>// server.template.ejs
    ...
    &lt;body&gt;
      &lt;div id="root"&gt;&lt;%%- appString %&gt;&lt;/div&gt;   //用ejs语法创建一个appString
      &lt;script&gt;
        window.__INITIAL__STATE__ = &lt;%%- initialState %&gt; //这种奇怪的命名方式是为了防止在客户端遇到命名冲突的问题
      &lt;/script&gt;
    &lt;/body&gt;
    ...</pre>
    <p>为什么ejs语法标签用了两个“%”？因为在webpack的HTMLPlugin去编译模板的时候，也是可以识别ejs语法的，如果默认写一个“%”，它就当是一个变量，在webpack编译的时候就把变量放进去了，就没有意义。两个“%”的写法，可以用ejs的一个loader让编译出来的结果是去掉一个“%”留一个“%”，还是一个ejs模板，可以在服务端渲染中使用。所以还要去改一下webpack.config.client.js下新建的HTMLPlugin，不能使用默认的loader，要新增一个loader，同时指定filename，以便方便地获取内容。</p>
    <p>安装ejs（服务端渲染时使用）和ejs-compiled-loader工具:</p>
    <pre>
    npm i ejs-compiled-loader ejs -S </pre>
    <p>重新启动npm run dev:client。然后继续修改dev-static.js，这时候getTemplate函数请求的就不是index.html了，而是server.ejs。</p>
    <pre>// dev-static.js
    ...
    const serialize = require('serialize-javascript');
    const ejs = require('ejs');
    const getTemplate = () => {  //通过webpack-dev-server实时地拿到最新的template文件
        return new Promise((resolve,reject) => {
            axios.get('http://localhost:8888/public/server.ejs')
                .then(res =>{
                    resolve(res.data);
                })
                .catch(reject);
        })
    };
    ...
            asyncBootstrap(app).then(() => {
              ...
              const state = getStoreState(stores);//拿到想要的值。需要一个方法把数据插到HTML内容里让客户端代码拿到。
              const content = ReactDomServer.renderToString(app);
              const html = ejs.render(template,{
                appString:content,
                initialState:serialize(state)
              });
              res.send(html);
            });
    ...</pre>
    <p>上面得到的常量state是个JavaScript对象，在模板里ejs是渲染成字符串，所以这里需要把state转成string。安装一个工具，帮助序列化JavaScript对象。</p>
    <pre>
    npm i serialize-javascript -S </pre>
    <p>刷新浏览器，查看网页源代码，可以看到window.__INITIAL__STATE__的值是一个对象,"count":3。而此时页面显示的count仍然是0。因为虽然在客户端拿到了需要的结果，但并没有设置到store里面去，这样store里面还是原来的内容。所以需要把初始化的数据设置到客户端的store里面。修改app-state.js:</p>
    <pre>// app-state.js
    ...
    export default class AppState {
      constructor({ count, name } = { count: 0, name: 'Jokcy' }) {
        this.count = count;
        this.name = name;
      }
      @observable count ;
      @observable name ;
    ...</pre>
    <p>然后在app.js中去读取__INITIAL__STATE__ :</p>
    <pre>// app.js
    ...
    const initialState = window.__INITIAL__STATE__ || {}; //eslint-disable-line
    const render = (Component) => {
      ReactDOM.hydrate(
        &lt;AppContainer&gt;
          &lt;Provider appState={new AppState(initialState.appState)}&gt;
    ...</pre>
    <p>刷新浏览器，可以看到前后端的数据统一了。</p>
    <h3>7,服务端问题解决mobx的warning以及增加title等SEO友好标签</h3>
    <h4>解决mobx的warning:</h4>
    <p>在启动dev:server时，Mobx可能会出现一个warning:there are multiple mobx instances active.This might lead to unexpected results。它告诉我们，在服务端渲染时，有多个Mobx实例被启动，这可能会造成不必要的错误。</p>
    <p>造成这个warning的原因是因为，对于server.entry.js是使用webpack进行打包的，而webpack-dev-server里面并没有把node_modules里安装的包区分出来，所以每次打包完成的内容都是个完整的包含react、Mobx这些类库的一整个js，这些东西都包含在一个js里。每次有代码更新，它重新编译出这整一个文件之后，前一份和后一份这两个bundle，他们里面都包含一个Mobx的实例。这就导致每一次有代码更新，重新去打包，每一份新的代码都会有一个单独的Mobx实例。这就是Mobx出现这个warning的原因。</p>
    <p>跑npm run build:server,把server bundle这个文件打包到硬盘上看一下实际输出的内容。在生成的dist目录下有个server.entry.js文件，文件内容非常大，里面包含的大部分代码是类库代码，像Mobx、react这些类库等，所以每次打包完成后这份js里就会包含一个Mobx实例。如何去解决这个问题呢？</p>
    <p>在webpack.config.server.js中增加一个配置externals,externals中指定的某些包，不打包到最终输出的js里面。</p>
    <pre>// webpack.config.server.js
    ...
    module.exports = webpackMerge(baseConfig,{
        ...
        externals:Object.keys(require('../package.json').dependencies), //dependencies中安装在node_module里的模块已经存在，而编译出的代码是在node环境中运行，所以这些类库可以通过require在js中调用。
        output:{
           ...
        }
    });</pre>
    <p>增加externals配置后，把包出的dist目录下的server.entry.js文件就非常小，不包含任何引用类库的代码。</p>
    <p>但在增加externals配置后，npm run dev:server报了一个“cannot find module 'react'”的错。这是因为在dev-static.js中，“m._compile(bundle,'server-entry.js'); ”将打包出的js字符串compile到一个module，使用这种方式无法使用require的模式去从node_modules里引用包。而在新的bundle里面因为模块并未打包在里面，需要通过modules里去require进来。如果解决这个矛盾呢？我们需要用新方法来解决：</p>
    <pre style="height: 300px;">// dev-static.js
    ...
    - const Module = module.constructor;
    + const NativeModule = require('module');
    + const vm = require('vm');
    + const getModuleFromString = (bundle, filename) => {
    +   const m = { exports: {} };
    +   const wrapper = NativeModule.wrap(bundle);
        // wrapper:`(function(exports,require,module,__filename,__dirname){ ... bundle code //真正要执行的代码 })`
        // 参数exports就是在bundle code中要执行的module.exports是一样的效果。
    +   const script = new vm.Script(wrapper,{
    +     filename: filename,
    +     displayErrors: true  //有错误信息时传出来
    +   });
    +   const result = script.runInThisContext();
    +   result.call(m.exports, m.exports, require, m);
    +   return m;
    + };
    ...
    serverCompiler.watch({},(err,stats) => {
        ...
        - const m = new Module;
        - m._compile(bundle,'server-entry.js');
        + const m = getModuleFromString(bundle,'server-entry.js');
        serverBundle = m.exports.default;
        createStoreMap = m.exports.createStoreMap;
    });
    ...</pre>
    <p>NativeModule其实就是nodejs的module.exports。‘module’是原生的模块，文档上并没有说明这部分内容。它有一个方法wrap()，可以把可执行的javascript代码包装成类似于`(function(exports,require,module,__filename,__dirname){ ... bundle code //真正要执行的代码 })`的方法。</p>
    <p>wrapper的这些参数是在这个执行环境下去使用的module、require、exports。这些东西wrap之后就成了字符串代码，去调用的时候就可以定制的方式去传入参数。去跑javascript字符串代码，需要用vm的Script类，并且可以去指定context执行环境。调用时，用call指定m.exports为调用者去调用result代码，参数exports就是m.exports，参数require就是当前环境下的require，参数module就是m。通过这种方式，让实际执行的bundle code执行完之后把m.exports的东西全部附在m对象上，这样就可以拿到想要的东西。</p>
    <p>getModuleFromString这个方法时如何解决上面报“cannot find module 'react'”的问题的呢？因为require是当前环境传进去的require，它是可以去require到node_modules里的代码的。这是一个常规的方法。</p>
    <h4>SEO:</h4>
    <p>服务端渲染很多情况下是为了去做SEO，SEO会看中‘title’和‘description’这些内容，是SEO里面非常重要的一部分。这些内容我们希望通过前后端通用的一种方式去实现。</p>
    <p>我们希望每个页面的title在相应页面里去定义。我们需要一个工具react-helmet去解决这个问题： </p>
    <pre>
    npm i react-helmet -S </pre>
    <p>然后打开topic-list/index.jsx :</p>
    <pre>// topic-list/index.jsx
    ...
    import Helmet from 'react-helmet'
    ...
        render() {
            return (
              &lt;div&gt;
                &lt;Helmet&gt;
                  &lt;title&gt;this is topic list&lt;/title&gt;
                  &lt;meta name="description" content="this is description" /&gt;
                &lt;/Helmet&gt;
                ...
              &lt;/div&gt;
            )
        }
    ...</pre>
    <p>增加的Helmet组件里的内容，需要作为服务端渲染时HTML上已经拥有的，这样SEO才能真正使用到这些信息。不然等js加载完成后再在页面上渲染出来，就没有效果了。所以在dev-static.js里修改：</p>
    <pre>// dev-static.js
    ...
    const Helmet = require('react-helmet').default; // 用export和import模式写的代码，需要加上.default
    ...
        asyncBootstrap(app).then(() => {
            if(routerContext.url){
                ...
            }
            const helmet = Helmet.rewind(); //在当前页面拿到需要显示的title、description这些东西
            ...
            const html = ejs.render(template,{
                appString:content,
                initialState:serialize(state),
                meta:helmet.meta.toString(),
                title:helmet.title.toString(),
                style:helmet.style.toString(),
                link:helmet.link.toString()
            });
            res.send(html);
        });
    ...</pre>
    <p>ejs里render的内容变了，所以ejs模板也要调整一下：</p>
    <pre>// server.template.ejs
    ...
    &lt;head&gt;
      ...
      - &lt;title&gt;Document&lt;/title&gt;
      + &lt;%%- meta %&gt;
      + &lt;%%- title %&gt;
      + &lt;%%- link %&gt;
      + &lt;%%- style %&gt;
    &lt;/head&gt;
    ...</pre>
    <p>重新请求list页面，发现meta便签和title的内容都出来了。</p>
    <h3>8,将服务端渲染用于生产环境</h3>
    <p>如何在开发时和上线时使用同一套代码来执行服务端渲染。首先在util目录下新建一个server-render.js文件，把整个服务端渲染的逻辑都放到这里：</p>
    <pre style="height: 300px;">// server-render.js
    const ReactDomServer = require('react-dom/server');
    const asyncBootstrap = require('react-async-bootstrapper');
    const serialize = require('serialize-javascript');
    const ejs = require('ejs');
    const Helmet = require('react-helmet').default; // 用export和import模式写的代码，需要加上.default
    const getStoreState = (stores) => {
      //这样就形成了在服务端渲染结束之后，数据的默认值的情况。
      return Object.keys(stores).reduce((result,storeName) => {
        result[storeName] = stores[storeName].toJson();
        return result
      },{})
    };

    module.exports = (bundle, template, req, res) => {
      return new Promise((resolve, reject) => {
        + const createStoreMap = bundle.createStoreMap;
        + const createApp = bundle.default;

        const routerContext = {};
        const stores = createStoreMap();
        const app = createApp(stores,routerContext,req.url);//createApp现在已不是一个直接可以渲染的内容，而是一个方法，所以需要根据这个方法去创建渲染内容。
        asyncBootstrap(app).then(() => {
          //asyncBootstrap方法执行app之后返回异步的结果，这个时候已经可以拿到routerContext。
          if(routerContext.url){
            res.status(302).setHeader('Location',routerContext.url);//通过在header上设置location去让浏览器自动跳转。
            res.end();//结束这次请求
            return
          }
          const helmet = Helmet.rewind(); //在当前页面拿到需要显示的title、description这些东西
          const state = getStoreState(stores);//拿到想要的值。需要一个方法把数据插到HTML内容里让客户端代码拿到。
          const content = ReactDomServer.renderToString(app);
          const html = ejs.render(template,{
            appString:content,
            initialState:serialize(state),
            meta:helmet.meta.toString(),
            title:helmet.title.toString(),
            style:helmet.style.toString(),
            link:helmet.link.toString()
          });
          res.send(html);
          // res.send(template.replace('&lt;!--app--&gt;',content));
          resolve();
        }).catch(reject);
      })
    };</pre>
    <p>整理之后，dev-static.js的内容变为：</p>
    <pre style="height: 300px;">// dev-static.js
    const path = require('path');
    const axios = require('axios');
    const webpack = require('webpack');
    const serverConfig = require('../../build/webpack.config.server');
    const MemoryFs = require('memory-fs');
    const proxy = require('http-proxy-middleware');
    const serverRender = require('./server-render');
    const getTemplate = () => {  //通过webpack-dev-server实时地拿到最新的template文件
        return new Promise((resolve,reject) => {
            axios.get('http://localhost:8888/public/server.ejs')
                .then(res =>{
                    resolve(res.data);
                })
                .catch(reject);
        })
    };
    const NativeModule = require('module');
    const vm = require('vm');
    const getModuleFromString = (bundle, filename) => {
      const m = { exports: {} };
      const wrapper = NativeModule.wrap(bundle);
      const script = new vm.Script(wrapper,{
        filename: filename,
        displayErrors: true
      });
      const result = script.runInThisContext();
      result.call(m.exports, m.exports, require, m);
      return m;
    };
    const mfs = new MemoryFs;
    const serverCompiler = webpack(serverConfig);
    serverCompiler.outputFileSystem = mfs;
    let serverBundle;
    serverCompiler.watch({},(err,stats) => {
        if(err) throw err;
        stats = stats.toJson();
        stats.errors.forEach(err => console.error(err));
        stats.warnings.forEach(warn => console.warn(warn));
        //读取server bundle的信息：
        const bundlePath = path.join(
            serverConfig.output.path,
            serverConfig.output.filename
        );//服务端bundle的整个路径
        const bundle = mfs.readFileSync(bundlePath,'utf-8'); //bundle是个string，并非在js中可使用的模块内容.
        const m = getModuleFromString(bundle,'server-entry.js');
        // serverBundle = m.exports.default;
        // createStoreMap = m.exports.createStoreMap; //把createStoreMap方法拿进来
        serverBundle = m.exports;
    });

    module.exports = function (app) {
        app.use('/public',proxy({
            target:'http://localhost:8888'
        }));
        app.get('*',function (req,res,next) {
            if (!serverBundle){
              //优化，webpack的compile正在执行，现在还没发去服务端渲染。这是开发时才会出现的情况。
              return res.send('waiting for compile, refresh later.')
            }
            //返回服务端渲染完成的结果给浏览器端
            getTemplate().then(template => {
              return serverRender(serverBundle,template,req,res)
            }).catch(next)
        });
    };</pre>
    <p>然后在正式环境下来执行服务端渲染。打开server.js :</p>
    <pre style="height: 300px;">// server.js
    ...
    - const ReactSSR = require('react-dom/server');
    + const serverRender = require('./util/server-render');
    ...
    if(!isDev){
        - const serverEntry = require('../dist/server.entry').default;
        - const template = fs.readFileSync(path.join(__dirname,'../dist/index.html'),'utf8');
        + const serverEntry = require('../dist/server.entry');
        + const template = fs.readFileSync(path.join(__dirname,'../dist/server.ejs'),'utf8');
        ...
        app.get('*',function (req,res) {
            - const appString = ReactSSR.renderToString(serverEntry);//服务端渲染得到的内容
            - res.send(template.replace('&lt;!--app--&gt;',appString));
            + serverRender(serverEntry,template,req,res).catch(next);
        });
    }else {
      ...
    }
    //对于next扔出来的错误，express有一个机制，在全局上可以定义一个error处理的中间件。
    //这个中间件会有一定的特殊，后三个参数虽然用不到但还是要传，因为express会去读取参数的长度判断到底是不是个error handler。
    app.use(function (error,req,res,next) {
      console.log(err);
      res.status(500).send(error);
    });
    ...</pre>
    <p>验证一下在正式环境里的服务端渲染。停掉之前的开发服务。然后npm run build ,再去package.json加一个scripts脚本命令“start”用来启动服务。</p>
    <pre>// package.json
    ...
    "scripts": {
        ...
        "start":"cross-env NODE_ENV=production node server/server.js"
      },
    ...</pre>
    <p>最后npm start启动服务就可以了。</p>
    <h4>服务端渲染逻辑：</h4>
    <p>1，得到服务端渲染的HTML内容</p>
    <p>2，同步store，使服务端渲染使用到的数据在客户端渲染时立马可以拿到而无需重新请求</p>
    <p>3，路由跳转，如果服务端渲染过程中有发现路由需要跳转，就直接redirect掉，而不用在客户端去redirect。因为如果在客户端redirect返回的内容是当前的页面内容，爬虫在爬取内容时就爬不到，这样对SEO会有问题。</p>
    <p>4，title之类的信息处理</p>
    <p>5，涉及到开发过程，修改代码希望能自动重新获取bundle，需要借助工具</p>

    <br/>
</div>

</body>
</html>