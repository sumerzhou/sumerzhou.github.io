<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title></title>
    <style>
        *{
            padding: 0;
            margin: 0 auto;
            line-height: 2em;
        }
        .box{
            width: 1000px;
            height: 100%;
        }
        .header{
            width: 980px;
            height:80px;
            background-color:RGB(96,56,17);
            opacity: 0.8;
            border-top:3px solid black;
            padding: 10px;
            margin-top: 20px;
            color: white;
            font-size: 40px;
            font-weight: bold;
            font-style: italic;
        }
        .header>span{
            display: block;
            float: left;
        }
        .main{
            width: 980px;
            border:2px solid RGB(96,56,17);
            border-radius: 20px;
            position: absolute;
            padding: 10px;
            margin-top: 10px;
        }
        h2{
            text-indent: 2em;
        }
        ul>li{
            text-indent: 2em;
            list-style: none;
        }
        .main span{
            display: block;
            width: 850px;
            background-color: palegoldenrod;
            padding-left: 30px;
            position: relative;
            left: -30px;
        }
    </style>
</head>
<body>
<div class="box">
    <div class="header">
        <span>Class</span><span style="margin-left: 550px;">About</span><span style="margin-left: 20px;">Message</span>
    </div>
    <div class="main">
        <h2>20170112-JS要点归纳（BOM、Array、Error、排序、垃圾回收机制、event事件（重点移动端事件））</h2>
        <p>1，BOM</p>
           <ul>
               <li>●概念：浏览器对象模型（Browser Object Model）。BOM使 JavaScript 有能力与浏览器“对话”。</li>
               <li>●BOM目前尚无正式标准。</li>
               <li>●所有浏览器都支持 window 对象。它表示浏览器窗口。</li>
               <li>●HTML DOM 的 document 也是 window 对象的属性之一。</li>
               <li>●Window 尺寸。三种方法能够确定浏览器窗口的尺寸（浏览器的视口，不包括工具栏和滚动条）。
                   <span>
                       <pre>
                           var w=window.innerWidth      //兼容IE、Chrome、Firefox、Opera 以及 Safari
                        || document.documentElement.clientWidth  //兼容IE 8、7、6、5
                        || document.body.clientWidth;     //兼容IE 8、7、6、5

                           var h=window.innerHeight
                        || document.documentElement.clientHeight
                        || document.body.clientHeight;
                       </pre>
                       注：screenLeft、screenTop、screenX、screenY声明了窗口的左上角在屏幕上的的 x 坐标
                       和 y 坐标。IE、Safari 和 Opera 支持 screenLeft 和 screenTop，而 Firefox 和 Safari
                       支持 screenX 和 screenY。
                   </span>
               </li>
               <li>●Window 对象常用方法:open()/prompt()/alert()/confirm()/setInterval()/setTimeout()</li>
           </ul>
        <p>2，Array</p>
           <ul>
               <li>concat(),返回一个新数组，这个新数组是由两个或更多数组组合而成的。</li>
               <li>join(),返回字符串值，其中包含了连接到一起的数组的所有元素，元素由指定的分隔符分隔开来。</li>
               <li>pop()/shift(),移除数组中的最后/第一个元素并返回该元素。</li>
               <li>push()/unshift(),将新元素添加到数组最后/开始位置，并返回数组的新长度值。</li>
               <li>reverse(),返回一个元素顺序被反转的 Array 对象。</li>
               <li>slice(),返回一个数组的一段。一直复制到 end 所指定的元素，但是不包括该元素。</li>
               <li>sort(),返回一个元素已经进行了排序的 Array 对象。</li>
               <li>splice(),从一个数组中移除一个或多个元素，如果必要，在所移除元素的位置上插入新元素，返回所移除的元素。</li>
               <li>toString(),返回对象的字符串表示。</li>
           </ul>
        <p>3，Error</p>
            <p style="text-indent: 2em;">在js中，有一个Error对象，我们通常可以用它来设置错误信息，或者设置异常捕捉。  </p>
                <span>
                  <pre>
                     （1）SyntaxError,解析代码时发生的语法错误.
                       // 变量名错误
                         var 1a;
                       // 缺少括号
                         console.log 'hello');
                     （2）ReferenceError,引用一个不存在的变量时发生的错误。
                          unknownVariable
                       // ReferenceError: unknownVariable is not defined
                         另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值。
                          console.log() = 1
                       // ReferenceError: Invalid left-hand side in assignment
                          this = 1
                       // ReferenceError: Invalid left-hand side in assignment
                     （3）RangeError,当一个值超出有效范围时发生的错误。
                          new Array(-1)
                       // RangeError: Invalid array length
                     （4）TypeError,变量或参数不是预期类型时发生的错误。
                          new 123
                       //TypeError: number is not a func
                          var obj = {}; obj.unknownMethod()
                       // TypeError: undefined is not a function
                       上面代码的第二种情况，调用对象不存在的方法，会抛出TypeError错误。
                  </pre>以上这几种派生错误，连同原始的Error对象，都是构造函数。开发者可以使用它们，人为生成错误对象的实例。<br/>
                    new Error("出错了！");<br/>
                    new RangeError("出错了，变量超出有效范围！");<br/>
                    new TypeError("出错了，变量类型无效！");<br/>
                    上面代码表示新建错误对象的实例，实质就是手动抛出错误。
              </span>
        <p>4，排序</p>
            <p style="text-indent: 2em;">熟练掌握冒泡排序。目前来说,排序最快的是快速排序法。了解更多排序请<a href="http://www.jb51.net/article/81520.htm">点击</a>这里。</p>
        <p>5，垃圾回收机制(<a href="http://www.jb51.net/article/75292.htm">更多详情请点击</a>)</p>
           <p style="text-indent: 2em;">Javascript具有自动垃圾回收机制(GC:Garbage Collecation)，会定期找出那些不在继续使用的变量，然后释放其内存。
               用于标记的无用变量的策略可能因实现而有所区别，通常情况下有两种实现方式：标记清除和引用计数。引用计数不太常用，标记清除较为常用。</p>
            <p style="text-indent: 2em;">js中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，
                永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。</p>
               <span><pre>
                          function test(){
                            var a = 10 ; //被标记 ，进入环境
                            var b = 20 ; //被标记 ，进入环境
                          }
                          test(); //执行完毕 之后 a、b又被标离开环境，被回收。</pre>
                </span>
               <p style="text-indent: 2em;">垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及
        被环境中的变量引用的变量的标记（闭包）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。
        最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</p>
                <p style="text-indent: 2em;">到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间
        间隔互不相同。</p>
        <p>6，event事件</p>
            <p style="text-indent: 2em;">使用touchstart、touchend、touchmove事件：</p>
            <span>
                <pre>
                     var img=document.getElementById('img');
                     img.addEventListener('touchmove',function(e){   //移动事件
                         var x= e.touches[0].clientX;
                         var y= e.touches[0].clientY;
                         img.style.left=x-300+'px';
                         img.style.top=y-200+'px';
                    });
                </pre>
            </span>
    </div>
</div>
</body>
</html>
<script>

</script>